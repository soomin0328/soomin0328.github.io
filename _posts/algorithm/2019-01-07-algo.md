---
layout: post
title: Hash - 프로그래머스
subtitle: 프로그래머스 Hash 문제들(4개)
date:   2019-01-07 12:00
categories: algorithm
tags: algorithm hash
permalink: /archivers/test
---
출처: [프로그래머스](https://programmers.co.kr/learn/courses/30/parts/12077)

# 1. 완주하지 못한 선수
### 1) 문제설명
수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.

마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.
### 2) 제한사항
- 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.
- completion의 길이는 participant의 길이보다 1 작습니다.
- 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.
- 참가자 중에는 동명이인이 있을 수 있습니다.

### 3) 입출력 예

| participant                                       | completion                               | return   |
|---------------------------------------------------|------------------------------------------|----------|
| ["leo", "kiki", "eden"]                           | ["eden", "kiki"]                         | "leo"    |
| ["marina", "josipa", "nikola", "vinko", "filipa"] | ["josipa", "filipa", "marina", "nikola"] | "vinko"  |
| ["mislav", "stanko", "mislav", "ana"]             | ["stanko", "ana", "mislav"]              | "mislav" |

### 4) 입출력 예 설명
예제 #1
leo는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.

예제 #2
vinko는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.

예제 #3
mislav는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다.

### 5) 풀이 과정
이 문제는 참여자 명단과 완주자 명단을 정렬하여 두 명단의 같은 ```index```의 값을 비교하여 해결 할 수 있다. 만약 참여자 명단에 있는 모든 사람이 완주자 명단에도 있다면&#10068; 배열을 정렬했을 때, 두 배열은 완벽히 같을 것이다.(같은 index의 값이 모두 같다!) 따라서 같은 ```index```의 값만 비교해준다면 누가 완주하지 못했는지 알 수 있다!

- 참여자 명단

| 0      | 1      | 2      |
|--------|--------|--------|
| "eden" | "kiki" |  "leo" |

- 완주자 명단

| 0      | 1      |
|--------|--------|
| "eden" | "kiki" |

<br>
위의 두 표는 첫 번째 입출력 예의 참여자 명단과 완주자 명단을 정렬한 결과다(index와 값). 얼핏 봐도 ```index 0```과 ```index 1```의 값은 두 배열이 같은데 ```index 2```의 값은 참여자 명단에만 존재한다! 따라서 "leo"는 참여만했지 완주하지 못한 것이다!!

### 6) 코드
```java
import java.util.*;

class Solution {
    public String solution(String[] participant, String[] completion) {
        Arrays.sort(participant);
        Arrays.sort(completion);
        int i;
        for(i=0; i<completion.length; i++){
            if(!participant[i].equals(completion[i])){
                return participant[i];
            }
        }
        return participant[i];
    }
}
```

```Arrays.sort()```로 두 배열을 정렬한 후, ```for문```을 이용하여 두 배열의 index의 값을 비교하여 두 값이 다를 때 그 값을 ```return```했다.

# 2. 전화번호 목록
### 1) 문제설명
전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다.
전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다.

- 구조대 : 119
- 박준영 : 97 674 223
- 지영석 : 11 9552 4421

전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요.

### 2) 제한 사항
- phone_book의 길이는 1 이상 1,000,000 이하입니다.
- 각 전화번호의 길이는 1 이상 20 이하입니다.

### 3) 입출력 예제

| phone_book                         | return|
|------------------------------------|-------|
| ["119", "97674223", "1195524421"]  | false |
| ["123", "456", "789"]              | true  |
| ["12", "123", "1235", "567", "88"] | false |

### 4) 입출력 예 설명
입출력 예 #1
앞에서 설명한 예와 같습니다.

입출력 예 #2
한 번호가 다른 번호의 접두사인 경우가 없으므로, 답은 true입니다.

입출력 예 #3
첫 번째 전화번호, “12”가 두 번째 전화번호 “123”의 접두사입니다. 따라서 답은 false입니다.

### 5) 풀이 과정
phone_book 배열에서 첫 번째부터 순서대로 pre로 정하여 배열 안의 pre를 제외한 다른 값들과 각각 비교한다. 두 값을 비교할 때, pre가 다른 값으로 시작하는지 알아보기 위하여 ```startsWith()```라는 메소드를 이용했다. ```startsWith()```를 몰랐다면 코드의 줄이 더 많았을 것이다...

### 6) 코드
```java
import java.util.*;

class Solution {
    public boolean solution(String[] phone_book) {
        boolean answer = true;
        String pre = "", post = "";
        
        for(int i=0; i<phone_book.length; i++){
            pre = phone_book[i];
            for(int j=0; j<phone_book.length; j++){
                if(i!=j){
                    post = phone_book[j];
                    if(pre.startsWith(post)){
                        answer = false;
                        break;
                    }
                }
            }
        }
        
        return answer;
    }
}
```
<br>
